Index: mine_seg_sat/dataset.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import random\nimport typing as T\nfrom pathlib import Path\n\nimport cv2\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport tifffile as tiff\nimport torch\n\nfrom mine_seg_sat.constants import (MAX_RESOLUTION, MID_RESOLUTION,\n                                    MIN_RESOLUTION)\n\n\nclass MineSATDataset(torch.utils.data.Dataset):\n    \"\"\"\n    Dataset for collection of binary masks and Sentinel-2 tiles containing mines.\n    \"\"\"\n\n    def __init__(\n            self,\n            split: str,\n            data_path: Path,\n            transformations: T.Any = None,\n            preprocessing: T.Any = None,\n            flatten_mask: bool = False,\n            use_mask: bool = True,\n            rescale: bool = True,\n            min_max_normalization: bool = True,\n            max_values: T.Optional[T.List[float]] = None,\n    ):\n        \"\"\"\n        Parameters:\n            split: Split to use, one of 'train', 'val', 'test'.\n            data_path: The root directory that contains the filepaths to the images and masks.\n            transformations: Transformations to apply to the images and masks.\n            flatten_mask: Whether to flatten the mask into a single channel.\n            use_mask: Whether to return a mask along with the image.\n            rescale: Whether or not to rescale all lower resolution bands up to the 10m resolution.\n            max_values: Maximum values for each band to use for rescaling. If None, then norm\n        \"\"\"\n        self.data_path = data_path\n        self.split = split\n        assert self.split in [\n            \"train\",\n            \"val\",\n            \"test\",\n        ], f\"Split must be one of 'train', 'val', 'test', got {self.split}\"\n        assert (\n                self.data_path / \"dataset_splits.csv\"\n        ).exists(), \"dataset_splits.csv not found in data_path.\"\n        self.use_mask = use_mask\n        self.rescale = rescale\n        self.min_max_normalization = min_max_normalization\n        if max_values is not None:\n            self.max_values = np.array(max_values)\n            self.min_values = np.zeros_like(self.max_values)\n\n        self.df = pd.read_csv(self.data_path / \"dataset_splits.csv\")\n        self.filepaths = self.df.loc[\n            self.df[\"split\"] == self.split, \"data_path\"\n        ].tolist()\n        self.maskpaths = self.df.loc[\n            self.df[\"split\"] == self.split, \"mask_path\"\n        ].tolist()\n        assert len(\n            self.filepaths) > 0, f\"No files found for split {self.split}\"\n        self.data_path = data_path\n        self.index_to_rgb = {\n            0: (0, 0, 0),\n            1: (212, 0, 0),\n        }\n\n        self.transformations = transformations\n        self.preprocessing = preprocessing\n        self.flatten_mask = flatten_mask\n        self.num_classes = 1\n\n    def __len__(self):\n        return len(self.filepaths)\n\n    def __getitem__(self, index: int, return_original: bool = False):\n        \"\"\"\n        Return the 12 bands of the image and the mask. Note that if the image is not 10m resolution,\n        then the lower resolution bands will be rescaled to 10m resolution if self.rescale is True.\n        Otherwise, the lower resolution bands will be returned as is.\n        \"\"\"\n        filepath = self.filepaths[index]\n        maskpath = self.maskpaths[index]\n        high_resolution_bands = np.stack(\n            [\n                tiff.imread(\n                    f\"{self.data_path.as_posix()}/{filepath}/{band}.tif\")\n                for band in MAX_RESOLUTION\n            ]\n        )\n        mid_resolution_bands = np.stack(\n            [\n                tiff.imread(\n                    f\"{self.data_path.as_posix()}/{filepath}/{band}.tif\")\n                for band in MID_RESOLUTION\n            ]\n        )\n        min_resolution_bands = np.stack(\n            [\n                tiff.imread(\n                    f\"{self.data_path.as_posix()}/{filepath}/{band}.tif\")\n                for band in MIN_RESOLUTION\n            ]\n        )\n        mask = tiff.imread(f\"{self.data_path.as_posix()}/{maskpath}/mask.tif\").astype(\n            \"int16\"\n        )\n\n        if self.rescale:\n            # Rescale lower resolution bands to 10m resolution\n            mid_resolution_bands = np.stack(\n                [\n                    cv2.resize(band, None, fx=2, fy=2,\n                               interpolation=cv2.INTER_CUBIC)\n                    for band in mid_resolution_bands\n                ]\n            )\n            min_resolution_bands = np.stack(\n                [\n                    cv2.resize(band, None, fx=6, fy=6,\n                               interpolation=cv2.INTER_CUBIC)\n                    for band in min_resolution_bands\n                ]\n            )\n            all_bands = np.concatenate(\n                [high_resolution_bands, mid_resolution_bands, min_resolution_bands],\n                axis=0,\n            ).astype(\"int16\")\n        else:\n            all_bands = [\n                high_resolution_bands,\n                mid_resolution_bands,\n                min_resolution_bands,\n            ]\n\n        if callable(self.transformations) and not return_original:\n            if isinstance(all_bands, np.ndarray):\n                all_bands = all_bands.transpose(\n                    1, 2, 0)  # (C, H, W) -> (H, W, C)\n                if self.min_max_normalization:\n                    all_bands = self.min_max_normalize(all_bands)\n                data = self.transformations(image=all_bands, mask=mask)\n                all_bands = data[\"image\"].to(dtype=torch.float32)\n                # all_bands = data[\"image\"].transpose(2, 0, 1)  # (H, W, C) -> (C, H, W)\n                mask = data[\"mask\"].to(dtype=torch.long)\n            else:\n                all_bands[0], all_bands[1], all_bands[2], mask = self.transformations(\n                    high=all_bands[0], mid=all_bands[1], low=all_bands[2], mask=mask\n                )\n\n        if self.flatten_mask:\n            mask = torch.nn.functional.one_hot(\n                mask.to(dtype=torch.long), self.num_classes\n            ).permute(2, 0, 1)\n\n        return (all_bands, mask)\n\n    def min_max_normalize(self, image: np.ndarray) -> np.ndarray:\n        # Get the minimum and maximum values for each band\n        return (image - self.min_values) / (self.max_values - self.min_values)\n\n    def colorize_mask(self, mask: np.ndarray):\n        \"\"\"\n        Given a mask, colorize it according to the legend.\n        \"\"\"\n        rgb_mask = np.zeros(mask.shape[:2] + (3,))\n        rgb_mask[mask == 0] = (0, 0, 0)\n        for index, color in self.index_to_rgb.items():\n            rgb_mask[mask == index] = color\n\n        return np.uint8(rgb_mask)\n\n    def get_image_and_mask(self, index: int) -> tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Get the image at the given index.\n        \"\"\"\n        filepath = self.filepaths[index]\n        maskpath = self.maskpaths[index]\n        high_resolution_bands = np.clip(\n            self.scale_band(\n                np.stack(\n                    [\n                        tiff.imread(\n                            f\"{self.data_path.as_posix()}/{filepath}/{band}.tif\"\n                        )\n                        for band in [\"B04\", \"B03\", \"B02\"]\n                    ],\n                    axis=-1,\n                )\n            ),\n            0,\n            1,\n        )\n        mask = tiff.imread(f\"{self.data_path.as_posix()}/{maskpath}/mask.tif\")\n\n        return (high_resolution_bands, mask)\n\n    def show_images_with_class(self, num_images: int = 5):\n        \"\"\"\n        Show images for the class that ends up appearing in the dataset.\n        \"\"\"\n        filepaths = self.df[[\"data_path\", \"mask_path\"]].values.tolist()\n        selected = random.sample(filepaths, num_images)\n        fig, axes = plt.subplots(num_images, 2, figsize=(10, num_images * 4))\n\n        for i, paths in enumerate(selected):\n            image = np.stack(\n                [\n                    np.clip(\n                        self.scale_band(\n                            tiff.imread(\n                                f\"{self.data_path.as_posix()}/{paths[0]}/{band}.tif\"\n                            )\n                        ),\n                        0,\n                        1,\n                    )\n                    for band in [\"B04\", \"B03\", \"B02\"]\n                ],\n                axis=-1,\n            )\n            mask = tiff.imread(\n                f\"{self.data_path.as_posix()}/{paths[1]}/mask.tif\")\n            title = self.parse_title(i)\n\n            axes[i, 0].imshow(image)\n            axes[i, 0].set_title(title)\n            axes[i, 0].axis(\"off\")\n\n            axes[i, 1].imshow(mask)\n            axes[i, 1].set_title(\"Mask\")\n            axes[i, 1].axis(\"off\")\n\n        fig.tight_layout()\n        plt.show()\n\n    def scale_band(self, band: np.ndarray, percentile: float = 95) -> np.ndarray:\n        \"\"\"\n        Scale the band to 0-1.\n        \"\"\"\n        return band / np.percentile(band, percentile)\n\n    def display_image_and_mask(self, index: int):\n        \"\"\"\n        Given an image index, display the image and mask.\n        \"\"\"\n        rgb, mask = self.get_image_and_mask(index)\n        mask = self.colorize_mask(mask)\n\n        fig, axes = plt.subplots(1, 2, figsize=(12, 6))\n        fig.tight_layout()\n\n        # Display the image\n        axes[0].imshow(rgb)\n        title = self.parse_title(index)\n        axes[0].set_title(title)\n        axes[0].axis(\"off\")\n\n        # Display the mask\n        axes[1].imshow(mask)\n        axes[1].set_title(\"Mask\")\n        axes[1].axis(\"off\")\n\n        plt.show()\n\n    def parse_title(self, index: int, show_tile: bool = False) -> str:\n        path = self.filepaths[index]\n        title = \"\"\n        if \"ab_mines\" in path:\n            title += \"Alberta\"\n        elif \"bc_mines\" in path:\n            title += \"British Columbia\"\n\n        if show_tile:\n            title += \" \" + path.split(\"/\")[-1]\n        if \"resource\" in self.df.columns:\n            title += (\n                    \" \"\n                    + self.df.loc[self.df.data_path == self.filepaths[index]][\n                        \"resource\"\n                    ].tolist()[0]\n            )\n            titles = title.split(\";\")\n            if len(titles) == 2:\n                title = \" & \".join(titles)\n            elif len(titles) > 2:\n                title = \", \".join(titles[:-1]) + \" & \" + titles[-1]\n\n        return title\n\n    def display_model_output(self, index: int, predicted_mask: np.ndarray):\n        \"\"\"\n        Given an image index, display the image, mask, and predicted mask.\n        \"\"\"\n        image, mask = self.get_image_and_mask(index)\n        if self.transformations is not None:\n            data = self.transformations(image=image, mask=mask.astype(\"int16\"))\n            image = data[\"image\"].numpy().transpose(1, 2, 0)\n            mask = data[\"mask\"].numpy()\n\n        mask = self.colorize_mask(mask)\n        predicted_mask = self.colorize_mask(predicted_mask)\n\n        # Create a color image using RGB bands\n        fig, axes = plt.subplots(1, 3, figsize=(8, 4))\n\n        # Display the image\n        axes[0].imshow(image)\n        title = self.parse_title(index)\n        axes[0].set_title(title)\n        axes[0].axis(\"off\")\n\n        # Display the mask\n        axes[1].imshow(mask)\n        axes[1].set_title(\"Mask\")\n        axes[1].axis(\"off\")\n\n        # Display the predicted mask\n        axes[2].imshow(predicted_mask)\n        axes[2].set_title(\"Predicted Mask\")\n        axes[2].axis(\"off\")\n\n        fig.tight_layout()\n        plt.show()\n\n    # @staticmethod\n    # def display_images(image_dict):\n    #     fig, axes = plt.subplots(2, 3, figsize=(12, 8))\n    #     fig.tight_layout()\n\n    #     for i, (title, image) in enumerate(image_dict.items()):\n    #         row = i // 3\n    #         col = i % 3\n    #         axes[row, col].imshow(image)\n    #         axes[row, col].set_title(title)\n    #         axes[row, col].axis(\"off\")\n\n    #     plt.show()\n    @staticmethod\n    # def display_images(image_dict):\n    #     num_images = len(image_dict)\n    #     # Calculate the number of rows based on the number of images\n    #     num_rows = int(np.ceil(num_images / 3.0))\n    #     fig, axes = plt.subplots(num_rows, 3, figsize=(12, 4 * num_rows))\n    #     fig.tight_layout()\n    #     for i, (title, image) in enumerate(image_dict.items()):\n    #         row = i // 3\n    #         col = i % 3\n    #         if num_rows == 1:  # If there's only one row, axes is a 1D array\n    #             ax = axes[col]\n    #         else:\n    #             ax = axes[row, col]\n    #         ax.imshow(image)\n    #         ax.set_title(title)\n    #         ax.axis(\"off\")\n    #     plt.show()\n    def display_images(image_dict):\n        num_images = len(image_dict)\n        # Calculate the number of rows based on the number of images\n        num_rows = int(np.ceil(num_images / 3.0))\n        fig, axes = plt.subplots(num_rows, 3, figsize=(12, 4 * num_rows))\n        fig.tight_layout()\n\n        for i, (title, image) in enumerate(image_dict.items()):\n            row = i // 3\n            col = i % 3\n            if num_rows == 1:  # If there's only one row, axes is a 1D array\n                ax = axes[col]\n            else:\n                ax = axes[row, col]\n\n            # Adjust colormap and normalization for NBR\n            if title == \"NBR\":\n                im = ax.imshow(image, cmap=plt.cm.RdYlGn, vmin=-1, vmax=1)\n                plt.colorbar(im, ax=ax, orientation='vertical')\n            else:\n                ax.imshow(image)\n\n            ax.set_title(title)\n            ax.axis(\"off\")\n\n        plt.show()\n\n    def display_transformed_images(self, index: int, percentile: int = 95):\n        \"\"\"\n        Generate Sentinel-2 images from the given filepath. The returned images are as follows:\n\n        NDVI: Normalized Difference Vegetation Index\n        NDBI: Normalized Difference Built-up Index\n        NDWI: Normalized Difference Water Index\n        False Color: B08, B04, B03\n        Mask: The class labels for each pixel\n        \"\"\"\n        # Unpack the bands\n        filepath = self.filepaths[index]\n        maskpath = self.maskpaths[index]\n        B02 = self.scale_band(\n            tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B02.tif\"),\n            percentile=percentile,\n        )\n        B03 = self.scale_band(\n            tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B03.tif\"),\n            percentile=percentile,\n        )\n        B04 = self.scale_band(\n            tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B04.tif\"),\n            percentile=percentile,\n        )\n        B07 = self.scale_band(\n            tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B07.tif\"),\n            percentile=percentile,\n        )\n        B08 = self.scale_band(\n            tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B08.tif\"),\n            percentile=percentile,\n        )\n\n        B11 = cv2.resize(\n            tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B11.tif\"),\n            None,\n            fx=2,\n            fy=2,\n            interpolation=cv2.INTER_CUBIC,\n        )\n        B12 = cv2.resize(\n            tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B12.tif\"),\n            None,\n            fx=2,\n            fy=2,\n            interpolation=cv2.INTER_CUBIC,\n        )\n        B11 = self.scale_band(B11, percentile=percentile)\n        B12 = self.scale_band(B12, percentile=percentile)\n\n        mask = tiff.imread(f\"{self.data_path.as_posix()}/{maskpath}/mask.tif\")\n        mask = self.colorize_mask(mask)\n\n        # Calculate NDVI (Normalized Difference Vegetation Index)\n        NDVI = (B08 - B04) / (B08 + B04)\n\n        # Calculate NDBI (Normalized Difference Built-Up Index)\n        NDBI = (B11 - B08) / (B11 + B08)\n\n        # Calculate NDWI (Normalized Difference Water Index)\n        NDWI = (B08 - B12) / (B08 + B12)\n\n        # Create a color image using RGB bands\n        RGB = np.stack([B04, B03, B02], axis=-1)\n\n        # Upscale B07 to match the resolution of B04\n        B07_rescaled = cv2.resize(\n            B07, (B04.shape[1], B04.shape[0]), interpolation=cv2.INTER_CUBIC)\n\n        # Now compute NBR\n        NBR = (B08 - B07_rescaled) / (B08 + B07_rescaled)\n        # Create a false-color composite image\n        false_color = np.stack([B08, B04, B03], axis=-1)\n\n        self.display_images(\n            {\n                \"NBR\": NBR,\n                \"NDVI\": NDVI,\n                \"NDBI\": NDBI,\n                \"NDWI\": NDWI,\n                \"RGB\": RGB,\n                \"False Color\": false_color,\n                \"Mask\": mask,\n            }\n        )\n\n    #\n    # def safe_divide(self, numerator, denominator):\n    #     \"\"\"Safely divide two arrays and handle division by zero.\"\"\"\n    #     with np.errstate(divide='ignore', invalid='ignore'):\n    #         result = numerator / denominator\n    #         result[~np.isfinite(result)] = 0  # Replace -inf, inf, NaN with 0\n    #     return result\n    #\n    # def get_transformed_images(self, index: int, percentile: int = 95):\n    #     \"\"\"\n    #     Generate Sentinel-2 images from the given filepath. The returned images are as follows:\n    #\n    #     NDVI: Normalized Difference Vegetation Index\n    #     NDBI: Normalized Difference Built-up Index\n    #     NDWI: Normalized Difference Water Index\n    #     False Color: B08, B04, B03\n    #     Mask: The class labels for each pixel\n    #     \"\"\"\n    #     image_dict = {}  # Initialize an empty dictionary to store images\n    #\n    #     try:\n    #         # Unpack the bands\n    #         filepath = self.filepaths[index]\n    #         maskpath = self.maskpaths[index]\n    #         B02 = self.scale_band(\n    #             tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B02.tif\"),\n    #             percentile=percentile,\n    #         )\n    #         B03 = self.scale_band(\n    #             tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B03.tif\"),\n    #             percentile=percentile,\n    #         )\n    #         B04 = self.scale_band(\n    #             tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B04.tif\"),\n    #             percentile=percentile,\n    #         )\n    #         B07 = self.scale_band(\n    #             tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B07.tif\"),\n    #             percentile=percentile,\n    #         )\n    #         B08 = self.scale_band(\n    #             tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B08.tif\"),\n    #             percentile=percentile,\n    #         )\n    #\n    #         NDVI = self.safe_divide(B08 - B04, B08 + B04)\n    #         # Upscale B07 to match the resolution of B04\n    #         B07_rescaled = cv2.resize(\n    #             B07, (B04.shape[1], B04.shape[0]), interpolation=cv2.INTER_CUBIC)\n    #\n    #         # Now compute NBR\n    #         NBR = (B08 - B07_rescaled) / (B08 + B07_rescaled)\n    #\n    #         # Create a color image using RGB bands\n    #         RGB = np.stack([B04, B03, B02], axis=-1)\n    #\n    #         # Add to the dictionary\n    #         image_dict[\"NBR\"] = NBR\n    #         image_dict[\"NDVI\"] = NDVI\n    #         image_dict[\"RGB\"] = RGB\n    #\n    #     except FileNotFoundError as e:\n    #         print(f\"File not found: {e}\")\n    #         # Additional error handling can be done here if needed\n    #\n    #     return image_dict\n\n    def get_images(self, index: int, percentile: int = 95):\n        \"\"\"\n        Generate Sentinel-2 images from the given filepath. The returned images are as follows:\n\n        NDVI: Normalized Difference Vegetation Index\n        NDBI: Normalized Difference Built-up Index\n        NDWI: Normalized Difference Water Index\n        False Color: B08, B04, B03\n        Mask: The class labels for each pixel\n        \"\"\"\n        # Unpack the bands\n        image_dict = {}  # Initialize an empty dictionary to store images\n\n        try:\n            filepath = self.filepaths[index]\n            maskpath = self.maskpaths[index]\n            B02 = self.scale_band(\n                tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B02.tif\"),\n                percentile=percentile,\n            )\n            B03 = self.scale_band(\n                tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B03.tif\"),\n                percentile=percentile,\n            )\n            B04 = self.scale_band(\n                tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B04.tif\"),\n                percentile=percentile,\n            )\n            B07 = self.scale_band(\n                tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B07.tif\"),\n                percentile=percentile,\n            )\n            B08 = self.scale_band(\n                tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B08.tif\"),\n                percentile=percentile,\n            )\n\n            B11 = cv2.resize(\n                tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B11.tif\"),\n                None,\n                fx=2,\n                fy=2,\n                interpolation=cv2.INTER_CUBIC,\n            )\n            B12 = cv2.resize(\n                tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B12.tif\"),\n                None,\n                fx=2,\n                fy=2,\n                interpolation=cv2.INTER_CUBIC,\n            )\n            B11 = self.scale_band(B11, percentile=percentile)\n            B12 = self.scale_band(B12, percentile=percentile)\n\n            mask = tiff.imread(f\"{self.data_path.as_posix()}/{maskpath}/mask.tif\")\n            mask = self.colorize_mask(mask)\n\n            # Calculate NDVI (Normalized Difference Vegetation Index)\n            NDVI = (B08 - B04) / (B08 + B04)\n\n            # Calculate NDBI (Normalized Difference Built-Up Index)\n            NDBI = (B11 - B08) / (B11 + B08)\n\n            # Calculate NDWI (Normalized Difference Water Index)\n            NDWI = (B08 - B12) / (B08 + B12)\n\n            # Create a color image using RGB bands\n            RGB = np.stack([B04, B03, B02], axis=-1)\n\n            # Upscale B07 to match the resolution of B04\n            B07_rescaled = cv2.resize(\n                B07, (B04.shape[1], B04.shape[0]), interpolation=cv2.INTER_CUBIC)\n\n            # Now compute NBR\n            NBR = (B08 - B07_rescaled) / (B08 + B07_rescaled)\n            # Create a false-color composite image\n            false_color = np.stack([B08, B04, B03], axis=-1)\n\n            # Add to the dictionary\n            image_dict[\"NBR\"] = NBR\n            image_dict[\"NDVI\"] = NDVI\n            image_dict[\"RGB\"] = RGB\n\n        except FileNotFoundError as e:\n            print(f\"File not found: {e}\")\n            # Additional error handling can be done here if needed\n\n\n\n        return image_dict\n\n    def get_numerical_values(self, index: int, percentile: int = 95):\n        \"\"\"\n        Calculate various indices and transformations based on satellite image bands.\n\n        Parameters:\n        index (int): Index of the image in the dataset.\n        percentile (int): Percentile value used for scaling the bands.\n\n        Returns:\n        dict: A dictionary containing numerical values for various indices and transformations.\n        \"\"\"\n        # Assuming that all the necessary functions and variables are defined elsewhere in the class\n        filepath = self.filepaths[index]\n        maskpath = self.maskpaths[index]\n\n        # Load and scale the bands\n        B02 = self.scale_band(tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B02.tif\"), percentile=percentile)\n        B03 = self.scale_band(tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B03.tif\"), percentile=percentile)\n        B04 = self.scale_band(tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B04.tif\"), percentile=percentile)\n        B07 = self.scale_band(tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B07.tif\"), percentile=percentile)\n        B08 = self.scale_band(tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B08.tif\"), percentile=percentile)\n\n        B11 = cv2.resize(tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B11.tif\"), None, fx=2, fy=2,\n                         interpolation=cv2.INTER_CUBIC)\n        B12 = cv2.resize(tiff.imread(f\"{self.data_path.as_posix()}/{filepath}/B12.tif\"), None, fx=2, fy=2,\n                         interpolation=cv2.INTER_CUBIC)\n        B11 = self.scale_band(B11, percentile=percentile)\n        B12 = self.scale_band(B12, percentile=percentile)\n\n        # Load and colorize the mask\n        mask = tiff.imread(f\"{self.data_path.as_posix()}/{maskpath}/mask.tif\")\n        mask = self.colorize_mask(mask)\n\n        # Calculate indices\n        NDVI = (B08 - B04) / (B08 + B04)\n        NDBI = (B11 - B08) / (B11 + B08)\n        NDWI = (B08 - B12) / (B08 + B12)\n\n        RGB = np.stack([B04, B03, B02], axis=-1)\n        B07_rescaled = cv2.resize(B07, (B04.shape[1], B04.shape[0]), interpolation=cv2.INTER_CUBIC)\n        NBR = (B08 - B07_rescaled) / (B08 + B07_rescaled)\n        false_color = np.stack([B08, B04, B03], axis=-1)\n\n        # Return as dictionary\n        return {\n            \"NBR\": NBR,\n            \"NDVI\": NDVI,\n            \"NDBI\": NDBI,\n            \"NDWI\": NDWI,\n            \"RGB\": RGB,\n            \"False Color\": false_color,\n            \"Mask\": mask\n        }\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mine_seg_sat/dataset.py b/mine_seg_sat/dataset.py
--- a/mine_seg_sat/dataset.py	(revision 39c8259172b4d34cbca042af67c9153121316c1f)
+++ b/mine_seg_sat/dataset.py	(date 1699467663385)
@@ -629,8 +629,6 @@
             print(f"File not found: {e}")
             # Additional error handling can be done here if needed
 
-
-
         return image_dict
 
     def get_numerical_values(self, index: int, percentile: int = 95):
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"7130a5a8-f14a-4e9a-ae8c-d2aaf3afffb5\" name=\"Changes\" comment=\"\" />\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\n      <map>\n        <entry key=\"$PROJECT_DIR$\" value=\"xm-algo\" />\n      </map>\n    </option>\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"MarkdownSettingsMigration\">\n    <option name=\"stateVersion\" value=\"1\" />\n  </component>\n  <component name=\"ProjectColorInfo\">{\n  &quot;associatedIndex&quot;: 8\n}</component>\n  <component name=\"ProjectId\" id=\"2WKRHaecmkR3MCcFMf7Pk5YuQ0d\" />\n  <component name=\"ProjectLevelVcsManager\">\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\n  </component>\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">{\n  &quot;keyToString&quot;: {\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\n    &quot;WebServerToolWindowFactoryState&quot;: &quot;false&quot;,\n    &quot;git-widget-placeholder&quot;: &quot;processed__image__folder&quot;,\n    &quot;last_opened_file_path&quot;: &quot;/Users/lilllmeng/PycharmProjects/Capstone/mine_seg_sat&quot;,\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\n    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,\n    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,\n    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,\n    &quot;settings.editor.selected.configurable&quot;: &quot;com.jetbrains.python.configuration.PyActiveSdkModuleConfigurable&quot;,\n    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;\n  }\n}</component>\n  <component name=\"RecentsManager\">\n    <key name=\"CopyFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$/mine_seg_sat\" />\n      <recent name=\"$PROJECT_DIR$/prepare_dataset\" />\n    </key>\n    <key name=\"MoveFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$\" />\n      <recent name=\"$PROJECT_DIR$/notebooks\" />\n    </key>\n  </component>\n  <component name=\"RunManager\">\n    <configuration name=\"organize_download_images\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"Capstone\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/mine_seg_sat\" />\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/mine_seg_sat/organize_download_images.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n    <recent_temporary>\n      <list>\n        <item itemvalue=\"Python.organize_download_images\" />\n        <item itemvalue=\"Python.organize_download_images\" />\n        <item itemvalue=\"Python.organize_download_images\" />\n        <item itemvalue=\"Python.organize_download_images\" />\n      </list>\n    </recent_temporary>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"7130a5a8-f14a-4e9a-ae8c-d2aaf3afffb5\" name=\"Changes\" comment=\"\" />\n      <created>1696479206476</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1696479206476</updated>\n      <workItem from=\"1696479212593\" duration=\"7469000\" />\n      <workItem from=\"1696615439422\" duration=\"1025000\" />\n      <workItem from=\"1696616473171\" duration=\"3298000\" />\n      <workItem from=\"1697036457399\" duration=\"5473000\" />\n      <workItem from=\"1697496654171\" duration=\"4463000\" />\n      <workItem from=\"1697566347611\" duration=\"4122000\" />\n      <workItem from=\"1697669322230\" duration=\"3525000\" />\n      <workItem from=\"1697672992339\" duration=\"966000\" />\n      <workItem from=\"1697673978909\" duration=\"3086000\" />\n      <workItem from=\"1697677078742\" duration=\"123000\" />\n      <workItem from=\"1697677222890\" duration=\"11761000\" />\n      <workItem from=\"1698108374537\" duration=\"320000\" />\n      <workItem from=\"1698110005063\" duration=\"1396000\" />\n      <workItem from=\"1698172823763\" duration=\"7000\" />\n      <workItem from=\"1698172973349\" duration=\"433000\" />\n      <workItem from=\"1698173537795\" duration=\"87000\" />\n      <workItem from=\"1698173696792\" duration=\"217000\" />\n      <workItem from=\"1698182470836\" duration=\"2321000\" />\n      <workItem from=\"1698190393271\" duration=\"212000\" />\n      <workItem from=\"1698209163847\" duration=\"1052000\" />\n      <workItem from=\"1698211105340\" duration=\"38000\" />\n      <workItem from=\"1698351050963\" duration=\"108000\" />\n      <workItem from=\"1698351325108\" duration=\"2308000\" />\n      <workItem from=\"1698358739562\" duration=\"2865000\" />\n      <workItem from=\"1698469335823\" duration=\"15000\" />\n      <workItem from=\"1698469417235\" duration=\"3310000\" />\n      <workItem from=\"1698689695012\" duration=\"127000\" />\n      <workItem from=\"1698689825919\" duration=\"32000\" />\n      <workItem from=\"1698689861607\" duration=\"709000\" />\n      <workItem from=\"1698690575038\" duration=\"904000\" />\n      <workItem from=\"1698691485820\" duration=\"213000\" />\n      <workItem from=\"1698691704598\" duration=\"271000\" />\n      <workItem from=\"1698691979910\" duration=\"38000\" />\n      <workItem from=\"1698692021757\" duration=\"102000\" />\n      <workItem from=\"1698692126786\" duration=\"10000\" />\n      <workItem from=\"1698692164735\" duration=\"1699000\" />\n      <workItem from=\"1699398531299\" duration=\"1036000\" />\n      <workItem from=\"1699399583506\" duration=\"134000\" />\n      <workItem from=\"1699399751925\" duration=\"831000\" />\n      <workItem from=\"1699400595470\" duration=\"87000\" />\n      <workItem from=\"1699400695340\" duration=\"381000\" />\n      <workItem from=\"1699401084367\" duration=\"543000\" />\n      <workItem from=\"1699401633929\" duration=\"268000\" />\n      <workItem from=\"1699401908383\" duration=\"19000\" />\n      <workItem from=\"1699401967657\" duration=\"537000\" />\n      <workItem from=\"1699402517604\" duration=\"305000\" />\n      <workItem from=\"1699402845244\" duration=\"849000\" />\n      <workItem from=\"1699403700481\" duration=\"43000\" />\n      <workItem from=\"1699403778686\" duration=\"234000\" />\n      <workItem from=\"1699404020269\" duration=\"834000\" />\n      <workItem from=\"1699404862569\" duration=\"122000\" />\n      <workItem from=\"1699405401542\" duration=\"509000\" />\n      <workItem from=\"1699405920298\" duration=\"962000\" />\n      <workItem from=\"1699407664157\" duration=\"625000\" />\n    </task>\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n  <component name=\"UnknownFeatures\">\n    <option featureType=\"com.intellij.fileTypeFactory\" implementationName=\".env\" />\n  </component>\n  <component name=\"com.intellij.coverage.CoverageDataManagerImpl\">\n    <SUITE FILE_PATH=\"coverage/Capstone$dataset.coverage\" NAME=\"dataset Coverage Results\" MODIFIED=\"1696544640523\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/mine_seg_sat\" />\n    <SUITE FILE_PATH=\"coverage/Capstone$organize_download_images.coverage\" NAME=\"organize_download_images Coverage Results\" MODIFIED=\"1698691620660\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/mine_seg_sat\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 39c8259172b4d34cbca042af67c9153121316c1f)
+++ b/.idea/workspace.xml	(date 1699415700809)
@@ -161,6 +161,20 @@
   <component name="UnknownFeatures">
     <option featureType="com.intellij.fileTypeFactory" implementationName=".env" />
   </component>
+  <component name="Vcs.Log.Tabs.Properties">
+    <option name="TAB_STATES">
+      <map>
+        <entry key="MAIN">
+          <value>
+            <State />
+          </value>
+        </entry>
+      </map>
+    </option>
+  </component>
+  <component name="VcsManagerConfiguration">
+    <option name="LAST_COMMIT_MESSAGE" value="" />
+  </component>
   <component name="com.intellij.coverage.CoverageDataManagerImpl">
     <SUITE FILE_PATH="coverage/Capstone$dataset.coverage" NAME="dataset Coverage Results" MODIFIED="1696544640523" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/mine_seg_sat" />
     <SUITE FILE_PATH="coverage/Capstone$organize_download_images.coverage" NAME="organize_download_images Coverage Results" MODIFIED="1698691620660" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/mine_seg_sat" />
